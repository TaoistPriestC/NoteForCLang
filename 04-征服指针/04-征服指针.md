### (一)内存分配模型

|   区域   |          作用域          |      生命周期      |
| :------: | :----------------------: | :----------------: |
| 全局内存 |         整个文件         | 应用程序的生命周期 |
| 静态内存 |     声明它的函数内部     | 应用程序的生命周期 |
| 局部内存 |     声明它的函数内部     |    函数执行期间    |
| 动态内存 | 由引用这块内存的指针决定 |    直至内存释放    |

　

#### **(1.1) 读懂指针的声明**

　　数据指针的长度通常是一样的，但是函数指针长度可能不同于数据指针。指针长度取决于使用的机器、编译器，现代Windows系统的指针，指针长度等于32bit或64bit。指针的声明很容易令人混淆，形如 “指向常量的指针”、“指向非常量的常量常量”、“指向常量的常量指针” 如果从左往右读取，会感觉写出来的代码比较混乱，但若自右向左读取声明，便很容易理解，可见读取变量声明应当像是读取赋值表达式那样，从右向左读取。

　

####  **(1.2) 内存管理相关的函数**

　　深入理解指针必须明白其如何进行内存管理，与之相关的函数包括 `malloc`、`free`、`calloc`、`realloc`，其均可操作堆区的内存。接下来重点介绍`calloc`与`realloc`函数，前者会在分配内存之后清空内存，相当于使用 `malloc + memset` ，后者会对已经分配得到的内存块进行缩小或扩大，如果没有足够的连续空间以供扩大，将在其它位置寻找新空间分配，如果缩小为零，则将释放指向的内存，利用`realloc`能实现迷你的`vector `和`string`容器。

　　关于释放内存，需要明白，程序结束之前释放内存未必是一件好事。堆一般通过系统功能实现管理内存，程序的进程创建之后，堆大小要么固定不变，要么继续增长，释放的内存仅能程序后续使用，所以程序首先分配内存，而后释放内存，若从OS角度来看，释放的这些内存不反应在程序的内存使用上，也就是说，打开任务管理器，某程序当前占用内存 30MB，若其运行过程中释放10MB 内存，其它条件保持不变，这个程序仍将占用 30MB 内存。相对简单的操作系统无法自动回收内存，需要程序员手动释放，但对现代大部分的OS来说，程序终止之前释放所有内存，有可能是得不偿失的。

　

####  **(1.3) 资源获取即初始化机制-RAII**

　　[RAII(Resource Acquisition Is Initialization)](https://zh.wikipedia.org/wiki/RAII)，这是C++语言的一种管理资源，避免泄漏的惯用方法，所谓资源是指 **网络套接字、互斥锁、文件句柄和内存等等**，利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

　　这种思想也能用于C，因为GNU编译器提供非标准的拓展来支持这项特性，也即对于 `gcc/g++` 编译器，可以使用 [cleanup 扩展实现](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization#GCC_extensions_for_C) ，code文件里面的`raii.c`给出了这种情况的代码，而在Windows平台可以使用微软提供的 `__try` 与 `__finally`，若是担心程序可移植性不好，也可以改用下文代码所示的 [setjmp/longjmp](https://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html) 机制。

```c

#define RAII_VARIABLE(vartype,varname,initval,dtor) \
    void _dtor_ ## varname (vartype * v) { dtor(*v); } \
    vartype varname __attribute__((cleanup(_dtor_ ## varname))) = (initval)
 
void raiiExample_for_GNU(){
    RAII_VARIABLE(char *, name, (char *)malloc(32), free);
    strcpy(name, "RAII Example");
    printf("%s\n", name);
}
```

```c
void raiiExample_for_windows(){
    int *pi = NULL;
    __try{
        pi = (int *)calloc(sizeof(int));
        printf("%d\n", *pi);
    }
    __finally{
        free(pi);
    }
}
```



### (二)指针与函数

　　与函数相关的数据指针操作主要包括：使用指针传递数据，以及返回指针两个场景。使用指针传递数据，通常是为了修改函数的外部数据，比如经典`swap(a,b)`实现，或是为了避免拷贝较大的自定义数据类型，若是希望数据是只读的(read-only)，可以使用`const`修饰，而令函数返回指针通常用于封装 `malloc`、`calloc`、`realloc` 等等内存分配操作，但是返回指针经常出现的忘记释放等一系列的问题。

**:tired_face:返回指针可能遇到的主要问题：**

- [x] 返回未初始化的指
- [x] 返回指针但是忘记释放内存
- [x] 返回指向无效地址的指针(比如函数内部的一些局部变量)

　　数据指针的长度是一致的，但是函数指针的长度未必相等。最好别将函数指针与数据指针互相转化，指针经历转化之后可能无法正常工作，即使`void`类型指针，也不可以接收函数指针。

　　与函数本身相关的指针，又称函数指针。函数指针持有函数地址，使用函数指针的人们主要可能会担心这种做法会使程序运行变慢，因为函数指针可能会使处理器无法配合流水线机制完成分支预测。分支预测是处理器用来推测哪一块代码会被执行的技术。流水线是用来提升处理器性能的技术，通过重叠指令实现。声明函数指针需要小心，因为C并不检查参数传递是否正确，下面的声明式说明`[]`与`()`运算符都优先于`*`运算符，由于函数指针的声明写起来很丑，建议使用之前，通过`typedef`为其设计一个别名。代码`pfunc.c`展示了函数指针的简单应用。

```c
void (*fptr)(int,int);
typedef void(*funcPtr)(int,int);
```





### (三)指针与数组

　　指针与数组是不等价的，若在main函数里面使用`sizeof`运算符测试二者的大小便可看出端倪，但其作为形参传给其它函数的，数据会被编译器强制转化变成指针，所以此时再用`sizeof`检测，看到的大小便是指针的字节数了。说回数组，由于动态分配的需求客观存在，指针的使用几乎必不可少，尤其是不定长度的二维数组，代码`iting.c`展示了不定二维数组的应用，如果使用C++提供的`vector`容器，实现起来其实是很简单的，但很可惜，没有如果。

　　二维数组的分配包括离散型和连续型，代码`array2d.c`展示了两种分配策略，而对连续型动态数组来说，其实亦可使用一维数组模拟二维数组，但是这样需要手动计算索引，对此可以手动封装一下。同理，这种做法可被推广到更高维度的数组。

```c
#define Item(m,i,j)  (*(m + (i * cols) + j))
...
int main(){
    int *matrix = (int *)malloc(rows * cols * sizeof(int));
    for (int i = 0; i < rows; i++){
        for (int j = 0; j < cols; j++){
            Item(matrix, i, j) = val;
        }
    }
    return 0;
}
```





### (四)指针与字符串

　　如果使用指针与字面量的方法声明一个字符串，那么这个字符串会被存在常量区，即使没有添加`const`修饰符，任何试图修改这个字符串的行为会弹出`Segmentation fault`错误，但是个别编译器也允许代码片段1这种做法，但我建议改用数组声明，像是代码片段2那样，便能正常打印`Lound`，可是使用字符数组初始化一个字符串是比较麻烦的，所以通常会用`strcpy`把字符串常量拷到字符数组里面。

```c
char* string = "Sound";
*string = 'L';
printf("str:%s, size = %ld\n", string, sizeof(string));
```

```c
char string[] = "Sound";
*string = 'L';
printf("str:%s, size = %ld\n", string, sizeof(string));
```

　　代码`str.c`展示了与字符串相关的一系列操作，如果想用函数封装并返回字符串，实际是返回字符串的地址。程序员必须关注返回地址的合法性，只有常量型的字面量与动态分配的内存两种对象能够正常返回，返回局部字符串与字符数组可能会引起问题，如果内存被其它栈帧覆盖，内部的数据便会损毁。




### (一)内存分配模型

|   区域   |          作用域          |      生命周期      |
| :------: | :----------------------: | :----------------: |
| 全局内存 |         整个文件         | 应用程序的生命周期 |
| 静态内存 |     声明它的函数内部     | 应用程序的生命周期 |
| 局部内存 |     声明它的函数内部     |    函数执行期间    |
| 动态内存 | 由引用这块内存的指针决定 |    直至内存释放    |

　

#### **(1.1) 读懂指针的声明**

　　数据指针的长度通常是一样的，但是函数指针长度可能不同于数据指针。指针长度取决于使用的机器、编译器，现代Windows系统的指针，指针长度等于32bit或64bit。指针的声明很容易令人混淆，形如 “指向常量的指针”、“指向非常量的常量常量”、“指向常量的常量指针” 如果从左往右读取，会感觉写出来的代码比较混乱，但若自右向左读取声明，便很容易理解，可见读取变量声明应当像是读取赋值表达式那样，从右向左读取。

　

####  **(1.2) 内存管理相关的函数**

　　深入理解指针必须明白其如何进行内存管理，与之相关的函数包括 `malloc`、`free`、`calloc`、`realloc`，其均可操作堆区的内存。接下来重点介绍`calloc`与`realloc`函数，前者会在分配内存之后清空内存，相当于使用 `malloc + memset` ，后者会对已经分配得到的内存块进行缩小或扩大，如果没有足够的连续空间以供扩大，将在其它位置寻找新空间分配，如果缩小为零，则将释放指向的内存，利用`realloc`能实现迷你的`vector `和`string`容器。

　　关于释放内存，需要明白，程序结束之前释放内存未必是一件好事。堆一般通过系统功能实现管理内存，程序的进程创建之后，堆大小要么固定不变，要么继续增长，释放的内存仅能程序后续使用，所以程序首先分配内存，而后释放内存，若从OS角度来看，释放的这些内存不反应在程序的内存使用上，也就是说，打开任务管理器，某程序当前占用内存 30MB，若其运行过程中释放10MB 内存，其它条件保持不变，这个程序仍将占用 30MB 内存。相对简单的操作系统无法自动回收内存，需要程序员手动释放，但对现代大部分的OS来说，程序终止之前释放所有内存，有可能是得不偿失的。

　

####  **(1.3) 资源获取即初始化机制-RAII**

　　[RAII(Resource Acquisition Is Initialization)](https://zh.wikipedia.org/wiki/RAII)，这是C++语言的一种管理资源，避免泄漏的惯用方法，所谓资源是指 **网络套接字、互斥锁、文件句柄和内存等等**，利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

　　这种思想也能用于C，因为GNU编译器提供非标准的拓展来支持这项特性，也即对于 `gcc/g++` 编译器，可以使用 [cleanup 扩展实现](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization#GCC_extensions_for_C) ，code文件里面的`raii.c`给出了这种情况的代码，而在Windows平台可以使用微软提供的 `__try` 与 `__finally`，若是担心程序可移植性不好，也可以改用下文代码所示的 [setjmp/longjmp](https://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html) 机制。

```c

#define RAII_VARIABLE(vartype,varname,initval,dtor) \
    void _dtor_ ## varname (vartype * v) { dtor(*v); } \
    vartype varname __attribute__((cleanup(_dtor_ ## varname))) = (initval)
 
void raiiExample_for_GNU(){
    RAII_VARIABLE(char *, name, (char *)malloc(32), free);
    strcpy(name, "RAII Example");
    printf("%s\n", name);
}
```

```c
void raiiExample_for_windows(){
    int *pi = NULL;
    __try{
        pi = (int *)calloc(sizeof(int));
        printf("%d\n", *pi);
    }
    __finally{
        free(pi);
    }
}
```



### (二)指针与函数

与函数相关的指针操作主要包括：使用指针传递数据，以及返回指针两个场景。使用指针传递数据，通常是为了修改函数的外部数据，比如经典`swap(a,b)`实现，或是为了避免拷贝较大的自定义数据类型，若是希望数据是只读的(read-only)，可以使用`const`修饰，而令函数返回指针通常用于封装 `malloc`、`calloc`、`realloc` 等等内存分配操作，但是返回指针经常出现的忘记释放等一系列的问题。

**返回指针可能遇到的主要问题：**

- [x] 返回未初始化的指
- [x] 返回指向无效地址的指针(比如函数内部的一些局部变量)
- [x] 返回指针但是忘记释放内存


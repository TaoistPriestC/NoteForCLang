### (一)面向对象

#### (1.1)构造与析构

　　众所周知，C++号称C超集，但是两者其实并非同一个语言，编程风格也截然不同，大部分所谓的C++代码仅仅是C with STL而非真正意义的C++，并未发挥面向对象，模板元编程这些工具的威力。征服指针的环节的`oop.c`代码使用结构体模拟了面向对象的继承，但是不管如何模仿，访问权限这些封装性功能都是无法实现的，对于不那么底层的编程来说，显然使用C++开发效率会更高一些。

　　面向对象最基本的操作便是创建对象，但是C++创建对象是不需要用到`new`关键字的，只有对象指针才会用到`new`。使用`struct/class`配合 `new`关键字会在堆区创建一个对象并返回一个指针，两个关键字的区别在于默认的访问权限不同，前者默认`public`，后者默认`private`，`new` 也能用于基础数据类型，及其构造数据类型。不妨回忆一下内存模型，我们按照数据保留于内存中的时间，能把变量的持续性分为自动存储持续性、静态存储持续性、线程存储持续性、动态存储持续性。分配于堆区的数据，具有所谓的动态存储持续性，需要手动释放，因而`new`创建的数据需要手动`delete`，不过如果数据是对象类型，其将调用析构函数。由于栈区先进后出的特点，析构顺序与构造顺序是相反的。

```c++
int main(){
    int *arr = new int[10];
    ...
	...
    delete[] arr;
    ...
    return 0;
}
```

**:fire:构造函数的调用方法包括下列三种：**

- [x] 默认构造法
- [x] 显式调用法
- [x] 隐式转化法

``` c++
//默认构造法
vector<int> vec(arr);
vector<int> vec(OtherVec);

// 显式调用法
vecotr<int> vec = Vector(arr); 
vecotr<int> vec = Vector(OtherVec);

// 隐式调用法
vector<int> vec = arr;
vector<int> vec = OtherVec;
```

　　通过默认法调用构造参数，其实代码写起来与变量声明几乎是一样的，千万别乱加什么圆括号，否则会被当做一条函数声明语句，这是因为函数内部也是可以编写函数声明语句的。显式调用法通常是用在含参的构造函数的，或者用于匿名对象，例如`DoSomething()`，匿名对象在其执行完毕之后立即被回收，可以将其看做是对构造函数的调用，但要注意别用拷贝构造函数来初始化一个匿名对象，否则括号会被认为是表示优先级的算符而被忽略。隐式调用法用得比较少，相当于显示调用法的简化，通常出现于类套类的情况中，会配合构造函数的初始化列表使用。

　

#### (1.2)深浅拷贝

　　如果自己不实现拷贝构造函数，编译器会默认提供一个浅拷贝的构造函数，浅拷贝是用赋值语句实现的，如果对象的成员变量包含指针、引用类型。浅拷贝会把地址作为变量值，此时赋值即为复制，极有可能出现[析构函数重复释放的错误](https://www.bilibili.com/video/BV1et411b73Z?p=110)。自行实现深拷贝往往需要递归拷贝。

　

#### (1.3)类对象包含的内容

　　一个类对象包括了成员属性、成员函数、友元声明。其中属性与方法都有访问权限限定，默认访问权限`private`，若想类外访问私有限定的属性或方法，要在内类做一个友元声明，在编程中不建议轻易使用友元，因为会破坏封装性，友元往往是与运算符重载一起使用的，详见下文3.2运算符重载的部分。

　　说回成员属性与成员函数，通常Java会把成员函数称为“方法” ，C++里面成员变量与成员函数是分开存储。使用`sizeof`运算符能够获取对象的大小，空对象`size = 1`，因为每个空对象也具有一个独一无二的空间，要用一字节空间以区分。静态变量与成员方法，则不在类对象本身，不影响`sizeof`获取的大小。

　　使用`this`关键字能够获取对象的成员变量，`this`指针会按上下文确定当前指向的对象是谁，`this`实质是一个指针常量，通过返回`*this`指针的解引用，并把返回值类型改为引用`Type&`，便能实现链式编程，比如`cin`、`cout`便采用了链式编程，这种思想JavaScript代码经常用到。此外，如果成员方法不涉及`this`，不涉及对于成员属性的访问，那么指向对象类型的空指针`NULL`也能调用正常调用成员方法。

　

#### (1.4)常函数与常对象

　　首先`this`指针本质是一个指针常量，相当于`Class *const this`，指针的指向是不可改变的，但是指针指向对象的属性是可以修改的，若在成员函数的末尾加上`const`声明常函数相当于是把`this`变为`const Class *const this`，此时成员函数无法修改成员变量。类似的，用于亦可声明自己的常对象，常对象仅能调用常方法。

```c++
const Person p;
```



　

### (二)引用与指针

　　引用变量是一种伪装指针，从其使用角度来看，非常像是`cosnt`指针，或说指针常量，一旦与某个变量关联将一直效忠于它，`rats_ref`扮演的角色与表达式`*rat_ptr` 非常相同。引用作为函数形参能使函数变量名成为调用程序中变量的别名。C仅能按值传递，即便是指针也是按值传递，其值为址，通过地址间接修改外部变量，但是C++引用能够直接允许函数访问调用函数中的变量。

```c++
int &rats_ref =  rats; // 引用声明
int *rats_ptr = &rats; // 指针声明
```

　　数组作为参数传递仅能使用指针，对于类对象建议使用引用传递参数，而对结构体可以根据个人风格选择指针或引用，通常来说使用引用出错的概率会小一些，但是对于多级的间接访问，指针显然会更强一点。



　

### (三)模板编程

#### (3.1)类型确定

　　通常使用模板写就的代码里面假定了变量可以执行哪些操作，比如语句`a=b`，但对数组来说，赋值语句是不成立，又如`a<b`或`b>a`对于结构体来说是不成立的，因而模板编程通常需要配合运算符重载一起使用，或者通过显式具体化的方法为某类型特定的代码定义，下列代码的先后顺序展示了三者的优先级：函数定义 > 显式具体化模板 > 函数模板。具体化不等于实例化。

```c++
void Swap(job&, job&);

template<> void Swap<> (job &, job &);
template<> void Swap<job> (job &, job &);

template<typename T> void Swap(T &, T &);
```

　　函数模板本身并不生成函数定义，其仅仅是一个用于的生成函数定义的方案，这一点不同于Java，编译器使用模板为特定类型生成函数定义时得到的是模板实例(instantiation)，比如传输`int`类型的`a`,`b`变量会使`swap(a,b)` 隐式的生成`swap(int,int)`函数实例，若想显示实例化亦可写成`swap<int>()`，但有一个问题，平时传参会有自动类型转化，但对指定`(int,int)`形参的函数模板传入`int`与`double`会报错，假如函数模板的代码要对不同类型的两个对象运算，比如`int`与`double`相加，情况会变得更加复杂，由于不知道`T1`与`T2`哪个数据类型更高，无法对其向上转型兼容，为确定其返回值可借助`decltype`关键字，`decltype(exp) var`运行分为三个步骤：

**:fire:判别类型的三个步骤：**

- [x] `exp`若为无括号包裹的标识符，与其标识符声明类型相同
- [x] `exp`若为函数调用，与返回值类型相同，但函数并未实际调用
- [x] `exp`若为左值，通常是带括号的变量，则为指向其类型的引用

```c++
template<typename T1, typename T2>
void ft(T1 x, T2 y){
    ...;
    decltype(x+y) xy = x + y;
    ...;
}
```

　

#### (3.2)运算符重载

　　运算符亦可看成是函数调用，`a+b`相当于`a.operator+(b)`，既然运算符是函数调用则自然可以重载。Python里面运算相关的魔法方法重载其实也是运算符重载的一种。通常自定义类型的函数重载通常是写在类内的，但也可以写在类外以全局函数的形式重载。此时`operator+(a,b)`相当于`a+b`，看起来很像前缀表达式，能写在内类尽量写在类内，通常只有重载`>>`、`<<`才会写在类外作为全局运算符重载，这是因为写在类型实现的效果是反方向的，详见`coutR.cpp`代码示例，`p`输出会变成`p<<cout`，如果非要写在内类则必须借助友元实现。

**:fire:友元修饰通常配合运算符重载使用，其包括三种不同的形式：**

- [x] 友元全局函数
- [x] 友元成员函数
- [x] 友元类

```c++
// 写在类外的运算符重载
Vector operator+(Vector &v1, Vector &v2);
Vector operator-(Vector &v1, Vector &v2);
```

```c++
namespace VECTOR{
    class Vector{
        public: enum Mode{RECT,POL};
        private:
            double x;
            double y;
            double mag;
            double ang;
        private:
            void set_mag();
            void set_ang();
            void set_x();
            void set_y();
        public:
            Vector();
            Vector(double n1, double n2, Mode form = RECT);
        public:
            void reset(double n1, double n2, Mode form = RECT);
            double get_x() const { return this->x; }
            double get_y() const { return this->y; }
            double get_mag() const { return this->mag; }
            double get_ang() const { return this->ang; }
            void polar_mode();
            void rect_mode();

        public:
            Vector operator+(const Vector &other) const;
            Vector operator-(const Vector &other) const;
            Vector operator+() const;
            Vector operator-() const;

        ...

        public:
            ~Vector();
    };
}

#endif
```


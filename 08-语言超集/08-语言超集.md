### (一)面向对象

#### (1.1)构造与析构

　　众所周知，C++号称C超集，但是两者其实并非同一个语言，编程风格也截然不同，大部分所谓的C++代码仅仅是C with STL而非真正意义的C++，并未发挥面向对象，模板元编程这些工具的威力。征服指针的环节的`oop.c`代码使用结构体模拟了面向对象的继承，但是不管如何模仿，访问权限这些封装性功能都是无法实现的，对于不那么底层的编程来说，显然使用C++开发效率会更高一些。

　　面向对象最基本的操作便是创建对象，但是C++创建对象是不需要用到`new`关键字的，只有对象指针才会用到`new`。使用`struct/class`配合 `new`关键字会在堆区创建一个对象并返回一个指针，两个关键字的区别在于默认的访问权限不同，前者默认`public`，后者默认`private`，`new` 也能用于基础数据类型，及其构造数据类型。不妨回忆一下内存模型，我们按照数据保留于内存中的时间，能把变量的持续性分为自动存储持续性、静态存储持续性、线程存储持续性、动态存储持续性。分配于堆区的数据，具有所谓的动态存储持续性，需要手动释放，因而`new`创建的数据需要手动`delete`，不过如果数据是对象类型，其将调用析构函数。由于栈区先进后出的特点，析构顺序与构造顺序是相反的。

```c++
int main(){
    int *arr = new int[10];
    ...
	...
    delete[] arr;
    ...
    return 0;
}
```

**:fire:构造函数的调用方法包括下列三种：**

- [x] 默认构造法
- [x] 显式调用法
- [x] 隐式转化法

``` c++
//默认构造法
vector<int> vec(arr);
vector<int> vec(OtherVec);

// 显式调用法
vecotr<int> vec = Vector(arr); 
vecotr<int> vec = Vector(OtherVec);

// 隐式调用法
vector<int> vec = arr;
vector<int> vec = OtherVec;
```

　　通过默认法调用构造参数，其实代码写起来与变量声明几乎是一样的，千万别乱加什么圆括号，否则会被当做一条函数声明语句，这是因为函数内部也是可以编写函数声明语句的。显式调用法通常是用在含参的构造函数的，或者用于匿名对象，例如`DoSomething()`，匿名对象在其执行完毕之后立即被回收，可以将其看做是对构造函数的调用，但要注意别用拷贝构造函数来初始化一个匿名对象，否则括号会被认为是表示优先级的算符而被忽略。隐式调用法用得比较少，相当于显示调用法的简化，通常出现于类套类的情况中，会配合构造函数的初始化列表使用。

　

#### (1.2)深浅拷贝

　　如果自己不实现拷贝构造函数，编译器会默认提供一个浅拷贝的构造函数，浅拷贝是用赋值语句实现的，如果对象的成员变量包含指针、引用类型。浅拷贝会把地址作为变量值，此时赋值即为复制，极有可能出现[析构函数重复释放的错误](https://www.bilibili.com/video/BV1et411b73Z?p=110)。

　

#### (1.3)成员变量与方法

　　通常Java会把成员函数称为“方法” ，C++里面成员变量与成员函数是分开存储。使用`sizeof`运算符能够获取对象的大小，空对象`size = 1`，因为每个空对象也具有一个独一无二的空间，要用一字节空间以区分。静态变量与成员方法，则不在类对象本身，不影响`sizeof`获取的大小。

　　使用`this`关键字能够获取对象的成员变量，`this`指针会按上下文确定当前指向的对象是谁，通过返回`*this`指针的解引用，并把返回值类型改为引用`Type&`，便能实现链式编程，比如`cin`、`cout`语句，这种思想JavaScript代码经常用到。

 

### (二)引用与指针

　　引用变量是一种伪装指针，从其使用角度来看，非常像是`cosnt`指针，一旦与某个变量关联将一直效忠于它，`rats_ref`扮演的角色与表达式`*rat_ptr` 非常相同。引用作为函数形参能使函数变量名成为调用程序中变量的别名。C仅能按值传递，即便是指针也是按值传递，其值为址，通过地址间接修改外部变量，但是C++引用能够直接允许函数访问调用函数中的变量。

```c++
int &rats_ref =  rats; // 引用声明
int *rats_ptr = &rats; // 指针声明
```

　　数组作为参数传递仅能使用指针，对于类对象建议使用引用传递参数，而对结构体可以根据个人风格选择指针或引用，通常来说使用引用出错的概率会小一些，但是对于多级的间接访问，指针显然会更强一点。



　

### (三)模板编程

#### (3.1)运算符重载

　　通常使用模板写就的代码里面假定了变量可以执行哪些操作，比如语句`a=b`，但对数组来说，赋值语句是不成立，又如`a<b`或`b>a`对于结构体来说是不成立的，因而模板编程通常需要配合运算符重载一起使用，或者通过显式具体化的方法为某类型特定的代码定义，下列代码的先后顺序展示了三者的优先级：函数定义 > 显式具体化模板 > 函数模板。具体化不等于实例化。

```c++
void Swap(job&, job&);

template<> void Swap<> (job &, job &);
template<> void Swap<job> (job &, job &);

template<typename T> void Swap(T &, T &);
```

　　函数模板本身并不生成函数定义，其仅仅是一个用于的生成函数定义的方案，这一点不同于Java，编译器使用模板为特定类型生成函数定义时得到的是模板实例(instantiation)，比如传输`int`类型的`a`,`b`变量会使`swap(a,b)` 隐式的生成`swap(int,int)`函数实例，若想显示实例化亦可写成`swap<int>()`，但有一个问题，平时传参会有自动类型转化，但对指定`(int,int)`形参的函数模板传入`int`与`double`会报错，假如函数模板的代码要对不同类型的两个对象运算，比如`int`与`double`相加，情况会变得更加复杂，由于不知道`T1`与`T2`哪个数据类型更高，无法对其向上转型兼容，为确定其返回值可借助`decltype`关键字，`decltype(exp) var`运行分为三个步骤：

**:fire:判别类型的三个步骤：**

- [x] `exp`若为无括号包裹的标识符，与其标识符声明类型相同
- [x] `exp`若为函数调用，与返回值类型相同，但函数并未实际调用
- [x] `exp`若为左值，通常是带括号的变量，则为指向其类型的引用

```c++
template<typename T1, typename T2>
void ft(T1 x, T2 y){
    ...;
    decltype(x+y) xy = x + y;
    ...;
}
```






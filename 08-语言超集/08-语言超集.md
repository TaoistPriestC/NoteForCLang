### (一)面向对象

　　周所周知，C++号称C超集，但是两者其实并非同一个语言，编程风格也截然不同，大部分所谓的C++代码仅仅是C with STL而非真正意义的C++，并非发挥面向对象，模板元编程这些工具的威力。征服指针的环节的`oop.c`代码使用结构体模拟了面向对象的继承，但是不管如何模仿，访问权限这些封装性功能都是无法实现的，对于不那么底层的编程来说，显然使用C++开发效率会更高一些。





### (二)引用与指针

　　引用变量是一种伪装指针，从其使用角度来看，非常像是`cosnt`指针，一旦与某个变量关联将一直效忠于它，`rats_ref`扮演的角色与表达式`*rat_ptr` 非常相同。引用作为函数形参能使函数变量名成为调用程序中变量的别名。C仅能按值传递，即便是指针也是按值传递，其值为址，通过地址间接修改外部变量，但是C++引用能够直接允许函数访问调用函数中的变量。

```c++
int &rats_ref =  rats; // 引用声明
int *rats_ptr = &rats; // 指针声明
```

　　数组作为参数传递仅能使用指针，对于类对象建议使用引用传递参数，而对结构体可以根据个人风格选择指针或引用，通常来说使用引用出错的概率会小一些，但是对于多级的间接访问，指针显然会更强一点。





### (三)模板编程

#### (3.1)运算符重载

　　通常使用模板写就的代码里面假定了变量可以执行哪些操作，比如语句`a=b`，但对数组来说，赋值语句是不成立，又如`a<b`或`b>a`对于结构体来说是不成立的，因而模板编程通常需要配合运算符重载一起使用，或者通过显式具体化的方法为某类型特定的代码定义，下列代码的先后顺序展示了三者的优先级：函数定义 > 显式具体化模板 > 函数模板。具体化不等于实例化。

```c++
void Swap(job&, job&);

template<> void Swap<> (job &, job &);
template<> void Swap<job> (job &, job &);

template<typename T> void Swap(T &, T &);
```

　　函数模板本身并不生成函数定义，其仅仅是一个用于的生成函数定义的方案，这一点不同于Java，编译器使用模板为特定类型生成函数定义时得到的是模板实例(instantiation)，比如传输`int`类型的`a`,`b`变量会使`swap(a,b)` 隐式的生成`swap(int,int)`函数实例，若想显示实例化亦可写成`swap<int>()`，但有一个问题，平时传参会有自动类型转化，但对指定`(int,int)`形参的函数模板传入`int`与`double`会报错，假如函数模板的代码要对不同类型的两个对象运算，比如`int`与`double`相加，情况会变得更加复杂，由于不知道`T1`与`T2`哪个数据类型更高，无法对其向上转型兼容，为确定其返回值可借助`decltype`关键字，`decltype(exp) var`运行分为三个步骤：

**:fire:判别类型的三个步骤：**

- [x] `exp`若为无括号包裹的标识符，与其标识符声明类型相同
- [x] `exp`若为函数调用，与返回值类型相同，但函数并未实际调用
- [x] `exp`若为左值，通常是带括号的变量，则为指向其类型的引用

```c++
template<typename T1, typename T2>
void ft(T1 x, T2 y){
    ...;
    decltype(x+y) xy = x + y;
    ...;
}
```





